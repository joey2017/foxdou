<?php
namespace App\Common\Command;

use SimpleRecord\Column;
use SimpleRecord\Connection\Connection;
use SimpleRecord\Connection\ConnectionManager;
use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;

/**
 * Class GenerateModelCommand
 * @package App\Common\Command
 */
class GenerateModelCommand extends ContainerAwareCommand {

    protected static $defaultName = 'generate:model';

    private $reservedWords = [
        'int', 'float', 'bool', 'string', 'true', 'false', 'null', 'void', 'iterable', 'object',
        '__halt_compiler', 'abstract', 'and', 'array', 'as', 'break', 'callable', 'case', 'catch', 'class', 'clone', 'const', 'continue', 'declare',
        'default', 'die', 'do', 'echo', 'else', 'elseif', 'empty', 'enddeclare', 'endfor', 'endforeach', 'endif', 'endswitch', 'endwhile', 'eval',
        'exit', 'extends', 'final', 'finally', 'for', 'foreach', 'function', 'global', 'goto', 'if', 'implements', 'include', 'include_once', 'instanceof',
        'insteadof', 'interface', 'isset', 'list', 'namespace', 'new', 'or', 'print', 'private', 'protected', 'public', 'require', 'require_once',
        'return', 'static', 'switch', 'throw', 'trait', 'try', 'unset', 'use', 'var', 'while', 'xor', 'yield',
        '__CLASS__', '__DIR__', '__FILE__', '__FUNCTION__', '__LINE__', '__METHOD__', '__NAMESPACE__', '__TRAIT__',
    ];

    /** @var SymfonyStyle */
    private $io;
    private $outputPath;
    private $modelMamespace;
    private $modelExtends;

    public function __construct() {
        parent::__construct();
    }

    /**
     * {@inheritdoc}
     */
    protected function configure() {
        $pos              = strrpos(__NAMESPACE__, '\\');
        $defaultNamespace = substr(__NAMESPACE__, 0, $pos) . '\Model\AutoGenerated';

        $appPos = strpos($defaultNamespace, 'App\\');
        $defaultDir = "{project_dir}/src/" . substr($defaultNamespace, $appPos + strlen('App\\'));
        $defaultDir = strtr($defaultDir, "\\", "/");

        $this
            ->setDescription('生成数据库表对应的 Model，用户的 Model 可以继承自这个 Model，不用担心自己的 Model 被覆盖')
            ->addOption('output-dir',  'o', InputOption::VALUE_OPTIONAL, "生成 Model 的保存路径，默认是本命令所在的目录的父目录下的 Model/AutoGenerated 目录", $defaultDir)
            ->addOption('namespace',   'N', InputOption::VALUE_OPTIONAL, "生成 Model 的 Namespace，默认是本命令所在命名空间的父命名空间下的 Model\AutoGenerated 命名空间", $defaultNamespace)
            ->addOption('extends',     'E', InputOption::VALUE_OPTIONAL, '生成 Model 的父类，默认是 /App/Common/Model/BaseModel (可以使用 / 来代替 \ )', '/App/Common/Model/BaseModel')
            ->addOption('table-prefix','p', InputOption::VALUE_OPTIONAL, '数据库表名前缀，如果指定，则会自动为指定的每个表自动加上前缀', 'yzb_')
            ->addOption('conflict-format', 'F', InputOption::VALUE_OPTIONAL, '当类名和 PHP 关键字冲突时，使用的重命名模板(sprintf格式)', "_%s")
            ->addOption('dry-run',     'd', InputOption::VALUE_NONE, '只打印出生成的 Model 源码，不写入文件')
            ->addArgument('tables', InputArgument::REQUIRED | InputArgument::IS_ARRAY, '要生成的数据库表列表，指定 all 来生成所有表')
            ->setHelp(<<<HELP
命令 <info>%command.name%</info> 为数据库中的每一个表自动生成一个 Model 对象，然后我们自己的 Model 可以继承自这个 Model，不用担心自己写的 Model 代码被覆盖。

语法：
  
    bin/console model:generate [options] [table1 [table2 [table3]...]]


默认保存路径：{$defaultDir}
默认命名空间：{$defaultNamespace}
默认继承父类：\SimpleRecord\Model

NOTE: 为了方便使用，避免不必要的转义错误，在指定命名空间的时候，您可以使用 / 来代替 \，比如 --extends /App/Model/BaseModel 

使用样例：

  bin/console model:generate \
    --output-dir=src/Common/Model/AutoGenerated \
    --namespace=App/Common/Model/AutoGenerated \
    --extends /App/Common/Model/BaseModel \
    --table-prefix=wtf
    users books comments

  将会为 wtf_users wtf_books wtf_comments 三个表生成对应的 Model 类

你也可以使用短参数：
  
  bin/console model:generate \
    -o src/Common/Model/AutoGenerated \
    -N App/Common/Model/AutoGenerated \
    -E /App/Common/Model/BaseModel \
    -p=wtf
    users books comments

HELP
            );
    }

    protected function initialize(InputInterface $input, OutputInterface $output) {
        // See https://symfony.com/doc/current/console/style.html
        $this->io = new SymfonyStyle($input, $output);
    }

    protected function execute(InputInterface $input, OutputInterface $output) {
        $outputDir     = $input->getOption('output-dir');
        $namespace     = strtr($input->getOption('namespace'), "/", "\\");
        $extends       = strtr($input->getOption('extends'), "/", "\\");
        $tablePrefix   = $input->getOption('table-prefix');
        $confictFormat = $input->getOption('conflict-format');
        $dryRun        = $input->getOption('dry-run');

        $tables        = $input->getArgument('tables');

        if(count($tables) === 1 && strtoupper($tables[0]) === 'ALL') {
            $tables = [];
        }

        if($tablePrefix) {
            $tables = array_map(function ($v) use ($tablePrefix) { return $tablePrefix . $v;}, $tables);
        }

        $tablePrefixStr = $tablePrefix ?: '(no prefix)';
        $tablesStr = $tables ? join(', ', $tables) : '(ALL)';
        $info = <<<EOF
outputDir:     {$outputDir}
namespace:     {$namespace}
extends:       {$extends}
tablePrefix:   {$tablePrefixStr}
tables:        {$tablesStr}

EOF;

        $this->io->section('实际参数值');
        $this->io->note($info);

        $conn = ConnectionManager::get_connection();
        $dbTables = $conn->tables();

        $failedTables = [];
        $pendingTables = $tables ?: $dbTables;

        $maxLength = 0;
        foreach ($pendingTables as $dbTable) {
            $maxLength = max($maxLength, strlen($dbTable));
        }

        $this->io->writeln("Generating models ...");
        foreach ($pendingTables as $tableName) {
            $str = str_pad("  {$tableName}...", $maxLength + strlen('...  '), '.');
            $this->io->write($str);
            if(!in_array($tableName, $dbTables)) {
                $this->io->writeln("<error>[FAILED]</error> (table doesn't exists)");
                continue;
            }

            list($modelFqcn, $renameFrom) = $this->generateModel($conn, $tableName, $outputDir, $namespace, $extends, $tablePrefix, $confictFormat, $dryRun);
            if($modelFqcn) {
                $msg = $renameFrom ? "<fg=yellow>[SUCCEED]</fg=yellow> ({$modelFqcn}) <== <error> RENAMED </error> from {$renameFrom}" : "<info>[SUCCEED]</info> ({$modelFqcn})";
            } else {
                $msg = "<error>[FAILED]</error>";
            }
            $this->io->writeln($msg);
        }
    }

    private function generateModel(Connection $conn, $tableName, $outputDir, $namespace, $extends, $tablePrefix, $confictFormat, $dryRun = false) {
        $typeMap = [
            Column::STRING   => 'string',
            Column::INTEGER  => 'int',
            Column::DECIMAL  => 'float',
            Column::DATETIME => '\SimpleRecord\DateTime',
            Column::DATE     => '\SimpleRecord\DateTime',
            Column::TIME     => '\SimpleRecord\DateTime',
        ];

        $primaryKeyClause = '';
        /** @var Column $column */
        $columns = $conn->columns($tableName);
        $annotations = "/**\n";
        foreach ($columns as $name => $column) {
            if($column->pk) {
                $primaryKeyClause = "static \$primary_key = '{$name}';";
            }
            $typeStr = $typeMap[$column->type];
            $typeStr = $column->nullable ? "{$typeStr}|null" : $typeStr;
            $comment = $column->default === null ? ' default: (NULL)' : " default: ({$column->default})";
            $comment .= $column->length ? ", max length: {$column->length}" : '';
            $comment .= ", raw type: {$column->raw_type}";

            $annotations .= " * @property {$typeStr} \${$name} {$comment}\n";
        }

        // $annotations .= ' * @method self find(...$args)'.PHP_EOL;
        // $annotations .= ' * @method self paginate(array $conditions, array $options = [], int $page = 1, int $page_size = 10)'.PHP_EOL;
        // $annotations .= ' * @method self all(array $conditions = [], array $options = [])'.PHP_EOL;
        // $annotations .= ' * @method self first(array $conditions = [], array $options = [])'.PHP_EOL;
        // $annotations .= ' * @method self last(array $conditions = [], array $options = [])'.PHP_EOL;

        $annotations .= " */";

        $renameFrom = null;
        $modelClassName = $tablePrefix === substr($tableName, 0, strlen($tablePrefix)) ? substr($tableName, strlen($tablePrefix)) : $tableName;
        if(in_array($modelClassName, $this->reservedWords) && $confictFormat) {
            $renameFrom = $modelClassName;
            $modelClassName = sprintf($confictFormat, $modelClassName);

        }

        $extends = $extends ? "extends {$extends}" : '';
        $tableTpl = $this->getClassTemplate();
        $search  = ['{namespace}', '{annotations}', '{class}',       '{extends}', '{raw_table_name}', '{primary_key}'];
        $replace = [$namespace,    $annotations,    $modelClassName, $extends,    $tableName,          $primaryKeyClause];
        $classSource = str_replace($search, $replace, $tableTpl);

        if($dryRun) {
            $this->io->section("Generated Model Source");
            $this->io->writeln($classSource);
        } else {
            $projectDir = $this->getContainer()->get('kernel')->getProjectDir();
            $outputDir = str_replace('{project_dir}', $projectDir, $outputDir);
            if(!file_exists($outputDir)) {
                mkdir($outputDir, 0755, true);
            }
            file_put_contents("{$outputDir}/{$modelClassName}.php", $classSource);
        }

        $modelFqcn = "{$namespace}\\{$modelClassName}";

        return [$modelFqcn, $renameFrom];
    }

    private function getClassTemplate() {
        return <<<TPL
<?php

// THIS FILE IS AUTO GENERATED FROM DATABASE TABLES
// DO NOT EDIT THIS FILE, OR YOUR MODIFICATIONS WILL BE LOST.
 
namespace {namespace};

{annotations}
class {class} {extends} {
    static \$table_name  = '{raw_table_name}';
    {primary_key}
}

TPL;

    }
}
